#! /bin/sh -e

# DP: Proposed patch for PR target/39431

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

On i[56]86 with -m32 -O2 -fpic and -march=i586 and higher
sync_double_compare_and_swap{,_cc}di_pic insn patterns need %eax, %edx, %ecx
and one of %esi or %edi registers and a memory address.  In addition to
this, %esp is reserved, %ebp is as well if frame pointer is needed and %ebx
is used as PIC pointer.  On i386 a valid memory address though may require
one or two registers, if it requires just one, we still can reload it,
but if it is a base + index{,*scale}, there aren't enough registers to
allocate.

The following patch fixes it by requiring that when -fpic the
sync_double_compare_and_swap{,_cc}di_pic patterns use a memory address
that either needs at most one register, or one or both of the registers
is %esp or %ebp.

Bootstrapped/regtested on x86_64-linux and i686-linux, ok for trunk?

2008-03-12  Jakub Jelinek  <jakub@redhat.com>

	PR target/39431
	* config/i386/predicates.md (cmpxchg8b_pic_memory_operand): New
	predicate.
	* config/i386/sync.md (sync_compare_and_swap<mode>,
	sync_compare_and_swap_cc<mode>): For DImode with -m32 -fpic check
	if operands[1] is cmpxchg8b_pic_memory_operand, if not force address
	into a register.
	(sync_double_compare_and_swapdi_pic,
	sync_double_compare_and_swap_ccdi_pic): Require operand 1 to be
	cmpxchg8b_pic_memory_operand instead of just memory_operand.

	* gcc.target/i386/pr39431.c: New test.

--- gcc/config/i386/predicates.md.jj	2009-02-20 14:56:00.000000000 +0100
+++ gcc/config/i386/predicates.md	2009-03-12 10:29:46.000000000 +0100
@@ -887,6 +887,34 @@
   return parts.disp != NULL_RTX;
 })
 
+;; Returns 1 if OP is memory operand which will need zero or
+;; one register at most, not counting stack pointer or frame pointer.
+(define_predicate "cmpxchg8b_pic_memory_operand"
+  (match_operand 0 "memory_operand")
+{
+  struct ix86_address parts;
+  int ok;
+
+  ok = ix86_decompose_address (XEXP (op, 0), &parts);
+  gcc_assert (ok);
+  if (parts.base == NULL_RTX
+      || parts.base == arg_pointer_rtx
+      || parts.base == frame_pointer_rtx
+      || parts.base == hard_frame_pointer_rtx
+      || parts.base == stack_pointer_rtx)
+    return 1;
+
+  if (parts.index == NULL_RTX
+      || parts.index == arg_pointer_rtx
+      || parts.index == frame_pointer_rtx
+      || parts.index == hard_frame_pointer_rtx
+      || parts.index == stack_pointer_rtx)
+    return 1;
+
+  return 0;
+})
+
+
 ;; Returns 1 if OP is memory operand that cannot be represented
 ;; by the modRM array.
 (define_predicate "long_memory_operand"
--- gcc/config/i386/sync.md.jj	2009-02-20 15:15:05.000000000 +0100
+++ gcc/config/i386/sync.md	2009-03-12 10:30:50.000000000 +0100
@@ -1,5 +1,5 @@
 ;; GCC machine description for i386 synchronization instructions.
-;; Copyright (C) 2005, 2006, 2007
+;; Copyright (C) 2005, 2006, 2007, 2009
 ;; Free Software Foundation, Inc.
 ;;
 ;; This file is part of GCC.
@@ -82,8 +82,15 @@
       low = force_reg (hmode, low);
       high = force_reg (hmode, high);
       if (<MODE>mode == DImode)
-	emit_insn (gen_sync_double_compare_and_swapdi
-		   (operands[0], operands[1], operands[2], low, high));
+	{
+	  if (flag_pic && !cmpxchg8b_pic_memory_operand (operands[1], DImode))
+	    operands[1] = replace_equiv_address (operands[1],
+						 force_reg (Pmode,
+							    XEXP (operands[1],
+								  0)));
+	  emit_insn (gen_sync_double_compare_and_swapdi
+		     (operands[0], operands[1], operands[2], low, high));
+	}
       else if (<MODE>mode == TImode)
 	emit_insn (gen_sync_double_compare_and_swapti
 		   (operands[0], operands[1], operands[2], low, high));
@@ -131,7 +138,7 @@
 ;; are just esi and edi.
 (define_insn "*sync_double_compare_and_swapdi_pic"
   [(set (match_operand:DI 0 "register_operand" "=A")
-	(match_operand:DI 1 "memory_operand" "+m"))
+	(match_operand:DI 1 "cmpxchg8b_pic_memory_operand" "+m"))
    (set (match_dup 1)
 	(unspec_volatile:DI
 	  [(match_dup 1)
@@ -173,8 +180,15 @@
       low = force_reg (hmode, low);
       high = force_reg (hmode, high);
       if (<MODE>mode == DImode)
-	emit_insn (gen_sync_double_compare_and_swap_ccdi
-		   (operands[0], operands[1], operands[2], low, high));
+	{
+	  if (flag_pic && !cmpxchg8b_pic_memory_operand (operands[1], DImode))
+	    operands[1] = replace_equiv_address (operands[1],
+						 force_reg (Pmode,
+							    XEXP (operands[1],
+								  0)));
+	  emit_insn (gen_sync_double_compare_and_swap_ccdi
+		     (operands[0], operands[1], operands[2], low, high));
+	}
       else if (<MODE>mode == TImode)
 	emit_insn (gen_sync_double_compare_and_swap_ccti
 		   (operands[0], operands[1], operands[2], low, high));
@@ -224,7 +238,7 @@
 ;; operand 3.
 (define_insn "*sync_double_compare_and_swap_ccdi_pic"
   [(set (match_operand:DI 0 "register_operand" "=A")
-	(match_operand:DI 1 "memory_operand" "+m"))
+	(match_operand:DI 1 "cmpxchg8b_pic_memory_operand" "+m"))
    (set (match_dup 1)
 	(unspec_volatile:DI
 	  [(match_dup 1)
--- gcc/testsuite/gcc.target/i386/pr39431.c.jj	2009-03-12 10:11:25.000000000 +0100
+++ gcc/testsuite/gcc.target/i386/pr39431.c	2009-03-12 10:11:36.000000000 +0100
@@ -0,0 +1,15 @@
+/* PR target/39431 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-options "-O2 -march=i686 -fpic" { target { ilp32 && fpic } } } */
+
+extern void bar (char *, int);
+
+int
+foo (long long *p, long long oldv, long long *q, int n)
+{
+  char buf[n];
+  bar (buf, n);
+  p[256 + n] = __sync_val_compare_and_swap (p + n, oldv, oldv + 6);
+  return __sync_bool_compare_and_swap (q + n, oldv, oldv + 8);
+}

	Jakub
